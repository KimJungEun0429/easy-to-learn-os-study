# 03. 스레싱과 프레임 할당
* 프레임 할당과 관련한 다양한 이론과 방법론을 살펴봅니다. 

## 1. 스레싱
### 1-1. 스레싱의 개념
* 개념: 하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태
* 예시: 여러 프로그램을 30개 정도 실행하면 하드디스크와의 입출력이 계속되어 프로그램이 정지한 것처럼 보이는 현상. 이유는 메모리가 꽉 찬 후에 새로운 프로그램을 메모리에 옮기려면 기존 프로그램을 스왑 영역으로 
이동시키는 횟수가 잦아지기 때문이다. 

### 1-2. 물리 메모리의 크기와 스레싱
* 스레싱은 메모리의 크기가 일정할 경우 멀티프로그램의 수와 밀접한 관계가 있다. 동시에 실행하는 프로그램의 수를 멀티프로그래밍 정도라고 하는데 멀티프로그래밍 정도가 너무 높으면 스레싱이 발생한다. 

<img width="370" alt="스크린샷 2022-10-17 오전 1 37 08" src="https://user-images.githubusercontent.com/77275707/196047222-ced3ff3b-610d-4929-aace-162b5a06b9f6.png">
* 멀티프로그래밍 정도와 CPU의 사용률의 관계를 나타낸 것이다. 프로그램의 수가 적을 때는 CPU 사용률이 계속 증가하다가 메모리가 꽉 차면 CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고 
새로운 페이지를 메모리에 가져오는 작업이 빈번해져서 CPU가 작업할 수 없는 상태 = 스레싱 발생 시점<br>
* [질문] 물리메모리를 늘리면 왜 컴퓨터가 빨라질까? 
컴퓨터는 운영체제를 포함하여 많은 프로그램을 동시에 실행한다. 자주 사용하는 프로세스가 필요로 하는 메모리보다 물리 메모리가 작다면 스레싱 발생 시점에 빨리 도달함 -> 컴퓨터가 전체적으로 느려짐 <br>
따라서 물리 메모리 크기를 늘리면 스레싱 발생 시점이 늦춰져서 프로세스를 원만하게 실행할 수 있다.<br>
추가로 물리 메모리가 작업을 하는데 충분한 크기가 되면 그 이후에는 크기를 늘려도 작업 속도에 영향을 미치지 않는다. <br>

### 1-3. 스레싱과 프레임 할당
* 스레싱은 각 프로세스에 프레임을 할당하는 문제와도 연관된다. 실행 중인 여러 프로세스에 프레임을 얼마나 나누어주느냐에 따라 시스템의 성능이 달라진다. 
* 따라서 남아있는 프레임을 실행 중인 프로세스에 적절히 나누어주는 정책이 필요하다. 프로세스에 프레임을 할당하는 방식은 크게 정적 할당과 동적 할당으로 구분된다. 

## 2. 정적 할당 
* 프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는 것으로 균등 할당 방식과 비례 할당 방식이 있다. 

### 2-1. 균등 할당 
* 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당한다. 
<img width="566" alt="스크린샷 2022-10-17 오전 1 46 04" src="https://user-images.githubusercontent.com/77275707/196047626-9e548bce-493b-46e4-8a42-dea06e7db335.png">

* 크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당받지 못하기 때문에 페이지 부재가 빈번하게 발생하고, 크기가 작은 프로세스의 경우 메모리가 낭비된다. 

### 2-2. 비례 할당
* 프로세스의 크기에 비례하여 프레임을 할당하는 방식이다. 
<img width="536" alt="스크린샷 2022-10-17 오전 1 48 04" src="https://user-images.githubusercontent.com/77275707/196047710-a8238340-077d-4c8f-bf10-4287d476e265.png">

* 프로세스의 크기를 고려하지 않은 고정 할당보다 좀 더 현실적인 방법이지만 두가지 문제점이 있다. 
1. 프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못한다.
2. 사용하지 않을 메모리를 처음부터 확보하여 공간을 낭비한다. 

## 3. 동적 할당 
* 프로세스는 실행 중에 많은 프레임이 필요하기도 하고, 적은 프레임만으로도 작동하기도 한다. 이렇게 시시각각 변하는 요청을 수용하는 방식으로 작업집합 모델을 사용하는 방식과 페이지 부재 빈도를 사용하는 방식이 있다. 

### 3-1. 작업집합 모델
* 지역성 이론을 바탕으로 하며, 가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다는 가정에서 출발한다. 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 
유지하여 프로세스의 실행을 돕는다.

<img width="384" alt="스크린샷 2022-10-17 오전 1 53 10" src="https://user-images.githubusercontent.com/77275707/196047943-96885078-0866-4a79-909b-3b7ad452ed4d.png">
* 작업집합 크기: 물리 메모리에 유지할 페이지의 크기
* 작업집합 윈도우: 작업집합에 포함되는 페이지의 범위

<img width="384" alt="스크린샷 2022-10-17 오전 1 53 10" src="https://user-images.githubusercontent.com/77275707/196047943-96885078-0866-4a79-909b-3b7ad452ed4d.png">

* 그림 9-26은 작업집합 윈도우를 10으로 잡고 범위를 델타로 표시했다. 델타 동안 참조된 10개의 페이지 중 작업집합에는 WS(t1)= {1, 7, 5, 2, 3}이 삽입되며, 이 페이지들은 다음번 윈도우에 도달할 때까지 물리 메모리에 보존된다. 작업집합 윈도우에는 현재 시점부터 시간적으로 가까운 페이지부터 삽입된다. 
* 작업 집합 크기는 작업집합에 들어갈 최대 페이지 수를 말하지만 얼마나 자주 작업집합을 갱신할 것인지도 의미한다. 

<img width="333" alt="스크린샷 2022-10-17 오전 1 57 22" src="https://user-images.githubusercontent.com/77275707/196048151-1bcf20d7-83ac-4ebb-a1f8-75f437e9729e.png">

* 그림 9-27에서는 작업 크기를 5로 설정했기 때문에 t1시점 이후에 5개 페이지에 접근하면 t2시점에 작업집합이 갱신된다. 또한 작업 집합 윈도우를 10으로 설정했기 때문에 t2시점에 10개 페이지를 살펴보고 
작업집합을 갱신한다. 원래 두번째 작업집합 윈도우에는 6개의 페이지가 있는데 작업집합 크기를 5로 설정했기 때문에 t2시점에 가까운 순서대로 작업집합에 삽입되고 가장 멀리 있는 5번 페이지는 속하지 못한다. 

* 작업집합 모델에서는 작업 집합 윈도우의 크기에 따라 프로세스의 실행 성능이 달라진다. 너무 크게 잡으면 필요없는 페이지가 남아서 다른 프로세스에 영향을 미치고, 너무 작게 잡으면 필요한 페이지가 스왑 영역으로 
옮겨져서 프로세스의 성능이 떨어진다. 

### 3-2. 페이지 부재 빈도
* 작업집합 모델의 경우 충분한 페이지와 프레임을 얼마나 할당해야 하는지 알 수 없는 문제가 있고 프로세스의 성능은 높일 수 있지만 스레싱 문제를 해결하지 못한다는 문제가 있었다. 
* 프로세스가 필요로 하는 페이지의 양을 동적으로 결정하는 방법 중에는 페이지 부재 빈도를 이용하는 것이 있다. 이는 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식이다. 
* 페이지 부재 비율의 상한선과 하한선을 설정하여 상한선을 초과하면 할당한 프레임이 적다는 것을 의미하므로 프레임을 추가하여 늘리고 반대로 페이지 부재 비율이 하한선 밑으로 내려가면 메모리가 낭비된다는 의미이므로 할당한
프레임을 회수한다.  
<img width="566" alt="스크린샷 2022-10-17 오전 2 06 32" src="https://user-images.githubusercontent.com/77275707/196048540-2102637b-6251-483e-bb6a-309729752f22.png">

* 프로세스가 처음 시작될 때는 페이지 할당량을 예측하기 어렵다. 페이지 부재 빈도 방식은 프로세스를 실행하면서 추가적으로 페이지를 할당하거나 회수하여 적정 페이지 할당량을 조절한다. 

