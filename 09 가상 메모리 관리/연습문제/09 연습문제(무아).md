# 연습문제
#### 1.메모리 가져오기 정책 중, 사용자가 요구할 때  해당 페이지를 메모리로 가져오는 방식은 무엇인가?
요구 페이징<br>

#### 2.요구 페이징과 반대로 앞으로 필요할 것이라고 예상되는 페이지를 미리 가져오는 방식은 무엇인가?
미리 가져오기로 대표적인 경우는 캐시이다.<br>

#### 3.페이지 테이블 엔트리의 구조 중, 페이지가 실제 메모리에 있는지 나타내는 비트는 무엇인가?
<img width="634" alt="스크린샷 2022-10-17 오전 12 36 19" src="https://user-images.githubusercontent.com/77275707/196044261-fbbf1509-a6dd-43bc-a810-e933d3311af8.png">

유효비트<br>

#### 4.페이지 테이블 엔트리의 구조 중, 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트는 무엇인가?
접근비트 <br>

#### 5.페이지 테이블 엔트리의 구조 중, 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트는 무엇인가?
변경비트 혹은 더티비트<br>

#### 6.프로세스가 페이지를 요청했을 때 해당 페이지가 메모리에 없는 상황을 무엇이라 하는가?
페이지 부재<br>

#### 7.기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되어 있는 성질을 무엇이라 하는가?
공간의 지역성<br>

* 페이지 교체 알고리즘: 프로세스가 요구한 페이지가 없으면 페이지 부재가 발생한다. 페이지 부재가 발생하면 스왑 영역에서 페이지를 메모리로 가져오는데 만약 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야 한다. 
 페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템 성능을 향상한다. <br>
 
#### 8.처음으로 메모리에 올라온 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
FIFO <br>

#### 9.미래의 접근 패턴을 기준으로 대상 페이지를 선정하여 스왑 영역으로 보내는 방식으로, 실제로 구현이 불가능한 페이지 교체 알고리즘은 무엇인가?
최적 알고리즘<br>

#### 10.시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
LRU: Least Recently Used page replacement algorithm<br>

#### 11.사용 빈도가 적은 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
LFU: Least Frequently Used page replacement algorithm<br>

#### 12.최근에 사용한 적이 없는 페이지를 스왑 영역으로 보내는 페이지 교체 알고리즘은 무엇인가?
NUR: Not Used Recently page replacemnet algorithm<br>

#### 13.FIFO 변형 페이지 교체 알고리즘 중, 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한번 더 주는 페이지 교체 알고리즘은 무엇인가?
2차 기회 페이지 교체 알고리즘<br>

#### 14.FIFO 변형 페이지 교체 알고리즘 중, 대상 페이지를 가리키는 포인터를 사용하여 포인터가 큐의 맨 바닥으로 내려가면 다음에 다시 큐의 처음을 가리키게 하는 페이지 교체 알고리즘은 무엇인가?
시계 알고리즘<br>

#### 15.하드디스크의 입출력이 많아져서 잦은 페이지 부재로 작업이 거의 멈춰버린 상태를 무엇이라 하는가?
스레싱<br>

#### 16.동적 프레임 할당 방식 중, 최근 일정 시간 동안 참조된 페이지를 집합으로 유지하고 이 집합에 있는 페이지들을 물리 메모리에 유지하는 것은 무엇인가?
작업집합 모델<br>

#### 17.동적 프레임 할당 방식 중, 페이지 부재 비율의 상한선과 하한선을 설정하고 페이지 부재 비율이 상한선을 초과하면 할당 프레임을 늘려주는 것은 무엇인가?
페이지 부재 빈도<br>

# 심화문제
#### 1.요구 페이징의 의미와 효과를 설명하시오
의미: 프로그램의 일부만 가져와 실행하고 사용자가 특정 기능을 요구할 때 해당 모듈을 메모리에 올린다. <br>
효과: 메모리의 절약, 메모리의 효율적 관리, 프로세스의 응답 속도 향상 등<br>

#### 2.세그먼테이션 오류와 페이지 부재의 차이를 설명하시오
세그먼테이션 오류: 사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근할 때 발생한다. 즉, 사용자 프로세스에 의해 발생하며 해당 프로세스를 강제 종료하여 해결한다.<br>
페이지 부재: 해당 페이지가 물리 메모리에 없을 때 발생하는 오류로 사용자 프로세스와 무관하다. 페이지 부재가 발생하면 메모리 관리자는 스왑 영역에서 해당 페이지를 물리 메모리로 옮긴 후 작업을 진행한다.<br>

#### 3.지역성의 의미를 설명하시오
기억장치에 접근하는 패턴이 메모리 전체에 고루 분포되는 것이 아니라 특정 영역에 집중되는 성질<br>
공간의 지역성: 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다는 것이다.<br>
시간의 지역성: 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다는 것이다.<br>
순차적 지역성: 여러 작업이 순서대로 진행되는 경향이 있다는 것을 의미한다. 일반적은 프로그래밍은 처음부터 마지막 순서로 진행되는 경향이 있다.<br>
<br>
지역성 이론은 많은 곳에서 사용되며 특히 캐시는 지역성 이론을 사용하는 대표적인 장치이다.<br>

#### 4.LRU 페이지 교체 알고리즘의 동작을 설명하시오
LRU: 메모리에 올라온 후 가장 오랫동안 사용하지 않은 페이지를 스왑 영역으로 옮긴다. <br>
 
<img width="660" alt="스크린샷 2022-10-17 오전 1 05 41" src="https://user-images.githubusercontent.com/77275707/196045778-4795125b-9ef8-4259-b925-9d3ab5f13ccc.png">
1.페이지에 접근한 시간을 기록하여 페이지에 접근한 지 가장 오래된 페이지를 교체한다. 즉 페이지에 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준으로 이루어진다. <br> 
맨 위의 숫자를 초 단위로 가정하고 페이지가 메모리에 올라오거나 사용될 때마다 그 시간을 사각형 아래에 표시한다. 그리고 시간을 확인하여 가장 오랫동안 접근하지 않았던 페이지를 스왑영역으로 올리고 그 자리에 다른 페이지를 올린다. <br>

2. 카운터에 기반한 구현은 페이지 접근 시간 대신 카운터 숫자로 기록하여 구현하는 방법이다. <br> 

접근 시간을 기록하거나 카운터를 하는 방법 모두 추가적인 메모리 공간을 필요로 한다는 단점이 있다. <br> 
<br> 
3. 참조 비트 시프트 방식의 동작 방식은 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것이다. 참조 비트의 초기값은 0이며 페이지에 접근할 때마다 1로 바뀐다. 또한 참조 비트는 주기적으로 오른쪽으로 한칸씩 이동한다. 

<img width="691" alt="스크린샷 2022-10-17 오전 1 12 06" src="https://user-images.githubusercontent.com/77275707/196046096-7c1c3255-d72e-4617-ba40-f8ab83bd272c.png">

* 이와 같은 방식으로 참조 비트를 갱신하다가 대상 페이지를 선정할 필요가 있으면 참조 비트 중 가장 작은 값을 대상 페이지로 선정한다. 
* 참조 비트 시프트 방식도 1B라는 공간을 사용하므로 공간을 낭비하는 것이 단점이다. 

#### 5.NUR 페이지 교체 알고리즘의 동작을 설명하시오
NUR: LRU, LFU 등의 페이지 교체 알고리즘과 성능이 비슷하면서도 불필요한 공간 낭비 문제를 해결한 알고리즘이다.<br>
페이지마다 참조 비트와 변경 비트를 가지므로 페이지마다 추가되는 메모리 공간이 2비트뿐이다. 여기서 참조 비트는 앞서 살펴보았던 PTE의 접근 비트를 가리키고, 변경 비트는 PTE의 변경 비트를 가리킨다. 참조 비트와 변경 비트는 초깃값이 0이며 다음과 같은 경우에 1이 된다. <br>
* 참조 비트: 페이지에 접근하면 1이 된다.
* 변경 비트: 페이지가 변경되면 1이 된다. 

<img width="642" alt="스크린샷 2022-10-17 오전 1 19 18" src="https://user-images.githubusercontent.com/77275707/196046418-bb824f61-d920-425a-b4f9-4c3bee51e05b.png">
* 최적 근접 알고리즘인 LRU, LFU, NUR 페이지 교체 알고리즘의 성능은 거의 비슷하며, NUR 페이지 교체 알고리즘은 2bit만 추가하여 다른 알고리즘과 유사한 성능을 낼 수 있고 쉽게 구현할 수 있기 때문에 가장 많이 사용된다. 

#### 6.프레임 할당 방식 중 정적 할당에 대해 설명하시오
프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는 것으로 균등 할당 방식과 비례 할당 방식이 있다. <br>
* 균등 할당: 프로세스의 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당한다.
* 비례 할당: 프로세스의 크기에 따라 프레임을 할당하는 방식이다. 

#### 7.프레임 할당 방식 중 동적 할당에 대해 설명하시오
정적 할당 방식은 프로세스를 실행하는 초기에 프레임을 할당하기 때문에 프로세스를 실행하는 동안 메모리 요구를 반영하지 못하는 단점이 있다. 프로세스는 실행 중에 어떤 때는 많은 프레임이 필요하기도 하고 어떨 때는 적은 프레임만으로도 작동한다. 이렇게 시시각각 변하는 요청을 수용하는 방식이 동적 할당 방식이다. <br>
* 작업집합 모델: 지역성 이론을 바탕으로 가장 최근에 접근한 프레임이 이후에도 또 참조할 가능성이 높다는 가정에서 출발해 최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지하여 프로세스의 실행을 돕는다. 
* 페이지 부재 빈도: 작업집합 모델의 경우 충분한 페이지를 할당하지 않으면 작업집합에 있는 페이지를 물리 메모리에 유지하기가 힘들다. 프로세스가 필요로 하는 페이지의 양을 동적으로 결정하는 방법 중 페이지 부재 빈도를 이용하는 것이 있다. 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식으로 페이지 부재 비율의 상한선과 하한선을 설정한다.  페이지 부재 비율이 상한선을 초과하면 할당한 프레임이 적다는 뜻이므로 프레임을 추가하여 늘린다. 반대로 페이지 부재 비율이 하한선 밑으로 내려가면 메모리가 낭비된다는 의미이므로 할당한 프레임을 회수한다. 

