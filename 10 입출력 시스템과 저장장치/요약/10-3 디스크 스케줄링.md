# 10-3. 디스크 스케줄링

## 디스크 스케줄링(disk scheduling)

다중 프로그래밍 환경에서 여러 프로세스가 동시에 디스크를 읽으려는 요청이 올 때 컴퓨터의 성능을 위해 효율적으로 처리해야 한다. 디스크를 읽는 시간은 매우 오래 걸리는 작업이고 특히 탐색 시간이 오래걸리므로 최대한 이 시간을 줄이는 것이 중요하다. 디스크 스케줄링은 디스크 접근 요청들을 검토하여 가장 효율적으로 처리하여 **탐색 시간을 줄이는 기법**이다.

<aside>
🗒️ 디스크의 데이터 전송 시간 = 탐색 시간 + 회전 지연 시간 + 전송 시간

</aside>

**예제로 쓰일 트랙 번호와 순번**

| 순번 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 트랙 번호 | 15 | 8 | 17 | 11 | 3 | 23 | 19 | 14 | 20 |

## 1. FCFS 디스크 스케줄링(First Come, First Service)

- 요청이 들어온 트랙 순서대로 서비스
- 헤드 총 이동 거리
    
    7 + 9 +6 +8 +20 + 4 +5 + 6 = 65
    

![https://user-images.githubusercontent.com/57691894/201478455-94f5c84f-4d34-4051-a594-a435cb319337.jpg](https://user-images.githubusercontent.com/57691894/201478455-94f5c84f-4d34-4051-a594-a435cb319337.jpg)

## 2. SSTF 디스크 스케줄링(Shortest Seek Time First)

- 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 서비스 (단, 거리가 같으면 먼저 요청받은 트랙 우선)
- 단점
    - 헤드가 중간에 위치하면 가장 안쪽이나 가장 바깥쪽에 있는 트랙은 서비스 받을 확률이 낮아지기 때문에 아사 현상 발생
- 효율성은 좋으나 공평성을 위배하므로 잘 사용되지 않는다.
- 헤드 총 이동 거리
    
    1 + 3 + 3 + 1 + 3 + 12 + 3 + 5 = 31
    

![https://user-images.githubusercontent.com/57691894/201478471-daf8b50d-8255-4f1f-89d0-13871f448c57.jpg](https://user-images.githubusercontent.com/57691894/201478471-daf8b50d-8255-4f1f-89d0-13871f448c57.jpg)

## 3. 블록 SSTF 디스크 스케줄링

- SSTF 디스크 스케줄링의 공평성 위배를 어느 정도 해결
- 큐에 있는 트랙 요청을 일정한 **블록 형태**로 묶고 그 안에서 가장 가까운 트랙부터 서비스

| 순번 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 트랙 번호 | 15 | 8 | 17 | 11 | 3 | 23 | 19 | 14 | 20 |
| 블록 SSTF | 15 | 17 | 8 | 11 | 3 | 23 | 20 | 19 | 14 |
- 헤드 총 이동 거리
    
    2 + 9 +3 +8 +20 + 3 + 1 + 5 = 51
    

![https://user-images.githubusercontent.com/57691894/201478496-63f4a432-d165-422b-968d-1967babe1334.jpg](https://user-images.githubusercontent.com/57691894/201478496-63f4a432-d165-422b-968d-1967babe1334.jpg)

## 4. SCAN 디스크 스케줄링

- SSTF 디스크 스케줄링의 공평성 위배를 완화
- 헤드가 한 방향으로만 움직이면서 맨 마지막 트랙에 도착할 때까지 뒤돌아가지 않고 요청받은 트랙을 서비스 (끝에 다다르면 방향 전환)
- 엘리베이터 기법이라고도 불림
- 헤드 총 이동 거리
    
    1 + 3 + 3 + 5 + 3 + 17 + 2 + 1 + 3 = 38
    
- 공평성을 덜 위배하면서도 성능이 좋아 많이 사용되는 기법 중 하나
- 단점
    - 아사 현상 : 동일한 트랙이나 실린더 요청이 연속적으로 발생하면 헤드가 더 이상 나아가지 못하고 제자리에 머물게 되어 바깥쪽 트랙에서 아사 현상 발생
    - 공평성 위배 : 헤드가 가장 바깥쪽 트랙을 한 번씩 방문하는 동안 중간에 있는 트랙은 두 번씩 방문하여 바깥쪽 트랙이 상대적으로 불이익

![https://user-images.githubusercontent.com/57691894/201478514-ab103015-4641-457b-aa4f-b5cf61415abc.jpg](https://user-images.githubusercontent.com/57691894/201478514-ab103015-4641-457b-aa4f-b5cf61415abc.jpg)

## 5. LOOK 디스크 스케줄링

- SCAN 디스크 스케줄링의 불필요한 부분을 제거하여 효율을 높인 기법
- SCAN 디스크 스케줄링과 달리 더 이상 서비스할 트랙이 없으면 마지막 트랙까지 가지 않고 중간에서 방향 전환
- 헤드 총 이동 거리
    
    1 + 3 + 3 + 5 + 17 + 2 + 1 + 3 = 35
    
- 많이 사용되는 기법

![https://user-images.githubusercontent.com/57691894/201478555-4f352fe2-1556-4a60-bbe0-07086d2e9501.jpg](https://user-images.githubusercontent.com/57691894/201478555-4f352fe2-1556-4a60-bbe0-07086d2e9501.jpg)

---

## 6. C-SCAN 디스크 스케줄링 (Circular SCAN)

- SCAN 디스크 스케줄링의 공평성 위배를 해결
- 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스하고, 반대 방향으로 돌아올 때는 서비스 하지 않고 이동만 한다.
- 헤드 총 이동 거리
    
    1 + 3 + 3 + 5 + 3 + 24 + 1 + 3 + 1 + 2 = 46
    
- 단점
    - SCAN 디스크 스케줄링의 아사 현상 동일
- 잘 사용되지 않음

![https://user-images.githubusercontent.com/57691894/201478534-e4b3a012-d0e4-4a92-ad37-864318e30ecb.jpg](https://user-images.githubusercontent.com/57691894/201478534-e4b3a012-d0e4-4a92-ad37-864318e30ecb.jpg)

## 7. C-LOOK 디스크 스케줄링(Circular LOOK)

- 한쪽 방향으로만 서비스하다가 더 이상 서비스할 트랙이 없으면 헤드가 중간에서 방향 전환하여 서비스하지 않고 이동만 한다.
- 헤드 총 이동 거리
    
    1 + 3 + 3 + 5 + 20 + 3 + 1 + 2 = 38
    

![https://user-images.githubusercontent.com/57691894/201478565-e60a2187-1d6b-42d2-b19e-917b7b03a773.jpg](https://user-images.githubusercontent.com/57691894/201478565-e60a2187-1d6b-42d2-b19e-917b7b03a773.jpg)

---

## 8. SLTF 디스크 스케줄링(Shortest Latency Time First)

대부분의 하드디스크는 트랙을 따라 움직이는 헤드를 갖는데, 앞에서 살펴본 기법들은 이러한 하드디스크에 적용되는 것들이었다.

이와 달리 SLTF는 **드럼**을 사용하는 일부 하드디스크에 적용되는 기법이다. 드럼을 사용하는 하드디스크는 헤드 지지대를 고정하고, 모든 트랙을 읽을 수 있는 여러 개의 헤드를 지지대에 부착한다. 이 때 헤드를 움직이는 탐색 시간이 없어서 매우 빠르게 데이터를 주고받을 수 있다. 여기에 적용되는 SLTF 스케줄링은 매우 고가라 많이 사용되지 않는다.

- 최소 지연 우선 기법
- 작업 요청이 들어온 섹터의 순서를 **디스크가 회전하는 방향에 맞추어 다시 정렬**한 후 서비스한다.
- ![https://user-images.githubusercontent.com/57691894/201478583-04ab9286-e5fa-4b2b-8961-bc78f717212b.jpg](https://user-images.githubusercontent.com/57691894/201478583-04ab9286-e5fa-4b2b-8961-bc78f717212b.jpg)
