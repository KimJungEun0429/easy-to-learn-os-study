1. 페이징 기법의 구현
 - 고정 분할 방식을 이용한 가상 메모리 관리 기법. 물리 주소 공간을 같은 크기로 나누어 사용.
   가상주소 : 프로세스 입장에서 바라본 메모리 공간. 항상 0번지부터 시작.
              -가상 주소의 분할된 각 영역은 페이지라고 부름. 번호를 매겨 관리함.
   물리주소 : 가상 주소의 페이지와 구분하기 위해 프레임이라고 부름. 프레임도 페이지와 마찬가지로 번호를 매겨 관리.
   
   => 페이지와 프레임의 크기는 같다.
   
2. 페이징 기법의 주소 변환
  2-1. 주소 변환 과정
      a. 프로세스가 30번지의 내용을 읽으려고 할 때의 주소 변환 과정.
      -① 가상 주소 30번지가 어느 페이지에 있는지 찾는다. 30번지는 페이지 3의 0번째에 위치한다.
      -② 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임1에 있다는 것을 알아낸다.
      -③ 최종적으로 물리 메모리 프레임 1의 0번째 위치에 접근한다. 이 주소가 가상 주소 30번지의 물리 주소다.

      b. 프로세스가 가상 주소 18번지에 어떤 값을 저장하려고 할 때의 주소 변환 과정
      -① 가상 주소 18번지가 어느 페이지에 있는지 찾는다. 18번지는 페이지 1의 8번째 위치에 있다.
      -② 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
      -③ 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장한다.
      
  2-2. 정형화된 주소 변환
      페이징 기법에서는 가상 주소를 VA=<P,D>로 표현함
      VA : 가상주소
      P  : 페이지
      D  : 페이지의 처음 위치에서 해당 주소까지의 거리
      EX) 가상 주소 18번지 => VA=<1,8>로 작성하며, 페이지 1의 8번째 주소라는 의미.
      
      페이징 기법에서의 주소 변환은 가상 주소 VA=<P,D>를 물리 주소 PA=<F,D>로 변환하는 것.
      PA : 물리 메모리 주소를 가리키는 용어. 물리 주소 또는 실제 주소라고 함.
      
      PA=<F,D>
      F : 프레임
      D : 프레임의 처음 위치에서 해당 주소까지의 거리
      EX) VA=<3,0>이 PA=<1,0>으로 변환되었다는 것은 가상 주소 30번지가 물리 주소 프레임 1의 0번 위치로 변환되었다는 말.
      
      결론적으로 페이징 기법의 주소 변환은 다음과 같다.
      
      VA=<P,D> -> PA = <F,D>로 변환될 때 페이지 테이블을 사용하여 P는 F로 바꾸고 D는 변경 없이 그대로 쓴다. D를 변경하지 않는 이유는 페이지와 프레임 크기를 똑같이 나누었기 때문
      페이지 테이블을 이용하면 간단하게 가상 주소를 물리 주소로 변환 가능. 페이지 테이블에서 페이지 번호를 찾아 해당 프레임 번호를 쫒아가면 된다.
      
      페이지 테이블
      -페이지 번호, 프레임 번호로 구성
      -각각의 한줄은 페이지 테이블 엔트리라고 부름
      
  2-3. 16bit CPU의 주소 변환 예
       가상 주소 30번지는 VA=<3,0>으로 간단하게 만들 수 있음. 하지만 컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할된다.
       페이지의 크기가 다양할 경우 가상 주소를 <P,D>로 변환하는 공식은 아래와 같다.
       
       P = 나눗셈(가상 주소/한 페이지의 크기)의 몫
       D = 나눗셈(가상 주소/한 페이지의 크기)의 나머지
       
       a. 프로세스가 980번지에 저장된 데이터를 요청했을 때, 가상 주소가 물리 주소로 바뀌는 과정
       -① 가상 주소 980번지의 페이지 P와 거리 D를 구한다. P는 0(980/1024의 몫), 거리는 980(980/1024)이므로 VA-<0,980>
       -② 페이지 테이블로 가서 페이지 0이 프레임 2에 저장되어 있다는 것을 확인한다.
       -③ 물리 메모리의 프레임 2 시작 지점으로부터 980번지 떨어진 곳에 접근하여 데이터를 가져온다.
       
 3. 페이지 테이블 관리
    페이지 테이블 관리가 복잡한 이유 : 시스템에 여러 개의 프로세스가 존재하고 프로세스마다 페이지 테이블이 하나씩 있기 때문.
    페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빨리 접근할 수 있어야 한다. 따라서 페이지 테이블은 물리 메모리 영역 중 운영체제 영역의 일부분에 
    모아놓는다. 시스템 내에는 여러 개의 프로세스가 존재하고 프로세스마다 하나의 페이지 테이블이 있기 때문에, 전체 페이지 테이블의 크기는 프로세스의 수에 비례해서 커진다.
    한 번에 실행하는 프로세스의 수가 많으면 페이지 테이블의 크기가 같이 커지고, 이에 따라 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.
    
    => 페이지 테이블의 크기를 적정하게 유지하는 것은 페이지 테이블 관리의 핵심이다.
    
    페이지 테이블에 빠르기 접근하기 위해 레지스터가 존재한다.
    
 4. 페이지 테이블 매핑 방식
   시스템 내에는 여러 개의 프로세스가 존재. 각 프로세스는 하나의 페이지 테이블을 가지며, 페이지 테이블은 운영체제 영역에 있음.
   페이지 테이블의 크기가 너무 커지면 프로세스가 실제로 사용할 수 있는 메모리 영역이 줄어든다.
   페이지 테이블 전체를 메모리에서 관리하느냐, 일부를 스왑 영역에서 관리하느냐에 따라 가상 주소를 물리 주소로 변환하는 방법이 달라짐.
   
   4-1. 직접 매핑
        페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식.
        별다른 부가 작업 없이 바로 주소 변환이 가능하기 때문에 직접 매핑이라 부름.
        
   4-2. 연관 매핑
        페이지 테이블 전체를 스왑 영역에서 관리하는 방식. 물리 메모리의 여유 공간이 작을 때 사용.
        페이지 테이블의 일부만 무작위로 가져옴. 일부  내용만 무작위로 배치하기 때문에 페이지 번호와 프레임 번호 둘 다 표시.
        물리 메모리 내의 페이지 테이블을 다 검색해야함. -> 이렇게 했는데도 원하는 프레임 번호를 얻지 못하면 스왑 영역에 있는 페이지 테이블을 검색.
        그래서 검색 실패 시 스왑 영역에서 다시 찾아야 하므로 시간이 낭비된다는 단점이 있음.
        
   4-3. 집합-연관 매핑
        연관 매핑의 문제를 개선한 방식.
        모든 페이지 테이블을 스왑 영역에서 관리하고 일부만 물리 메모리로 가져온다는 것은 연관 매핑과 동일.
        연관 매핑의 단점과 달리 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져옴.
        집합 테이블을 통해 원하는 페이지 테이블 엔트리가 스왑 영역에 있는지, 물리 메모리에 있는지 간단히 파악할 수 있음. 
        연관 매핑에서처럼 물리 메모리의 모든 페이지 테이블을 검사할 필요가 없어 주소 변환 시간이 단축됨.
        
   4-4. 역매핑
        앞의 세가지 매핑과 반대로 페이지 테이블을 구성하는 방식. 
        직접,연관,집합-연관 매핑에서는 페이지 번호를 기준으로 테이블을 구성하지만, 역매핑은 물리 메모리의 프레임 번호를 기준으로 구성. 
        -> 물리 메모리의 프레임에 어떤 프로세스의 어떤 페이지가 올라와 있는지를 표시.
        프로세스의 수와 상관없이 테이블이 하나만 존재한다는 것. -> 테이블의 크기가 매우 작다는 것이 장점이다.
        테이블의 크기가 작지만, 가상 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 한다는 단점이 있다.
        모든 페이지를 검색한 후에야 해당 페이지가 스왑 영역에 있다는 것을 알게 되므로 속도가 아주 느리다.
        
   
